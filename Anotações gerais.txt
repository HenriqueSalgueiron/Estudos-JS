--------------------------------------------------------------------------------------------------------------------------------------------------------
PRIMEIRO HTML - Aula 4

escrever "html" e selecionar "html:5" para obter um esqueleto. Consultar detalhes no "Aula 4_Primeiro HTML.html"

alguns comandos: 

window.alert('Minha primeira mensagem!') // Pop up com uma mensagem de alerta
window.confirm('Está gostando de estudar?') // Janela com OK ou Cancelar
window.prompt('Qual o seu nome?') // Campo aberto que recebe uma mensagem

--------------------------------------------------------------------------------------------------------------------------------------------------------
VARIÁVEIS E TIPOS PRIMITIVOS (declarar) - Aula 5

Nome da variável = "Identificadores"

1) Podem começar com letra, $ ou _
2) Não pode começar com número
3) É possível usar letras ou números
4) É possível usar acentos e símbolos
5) Não pode conter espaço
6) Não podem ser palavras reservadas (palavras que o JS utiliza)

Dicas para declarar variáveis: 

1) Maiúsculas e minúsculas fazem diferença
2) Tente escolher nomes coerentes para as variáveis

--------------------------------------------------------------------------------------------------------------------------------------------------------
TRATAMENTO DE DADOS - Aula 6 
--------------------------------------------------------------------------------------------------------------------------------------------------------

OPERADORES - Aula 7 e 8

Operadores Aritméticos:

	5 + 2 = 7
	5 - 2 = 3
	5 * 2 = 10
	5 / 2 = 2.5
	5 % 2 = 1
	5 ** 2 = 25

	X += 2    ==   x = x + 2
	X -= 2    ==   x = x - 2
	X *= 2    ==   x = x * 2
	X /= 2    ==   x = x / 2
	X %= 2    ==   x = x % 2
	X **= 2    ==   x = x ** 2

	X++       == X+1
	X--       == X-1

Relacionais:

	> maior que
	< menor que
	>= maior ou igual
	<= menor ou igual
	== igual 
	!= diferente

	obs: resultados boleanos (true ou false)

Identidade:

	5 == 5     -> true
	5 == '5'   -> true / O sinal de igualdade do JS não testa o tipo, apenas a grandeza. por isso é igual
	5 === '5'  -> false / "Igualdade restrita", testa se eles são identicos (valor e tipo)

Lógicos:	

	! negação
	&& conjunção (e)
	|| disjunção (ou)

Ternário:

	(teste)?(se true):(se false)

	exemplo: média >= 7.0 ? "Aprovado" : "Reprovado"
	traduzindo: se a média for maior ou igual a 7, aparecerá aprovado. senão, aparecerá reprovado

--------------------------------------------------------------------------------------------------------------------------------------------------------
DOM (Document object Model) - Aula 9

Definição: 

	Conjunto de objetos dentro do navegador que darão acesso aos componentes do website.
	O DOM não está dentro do Node.js, está no navegador. Por isso fazemos um "site".

Árvore DOM:

	Árvore DOM do site vai da raíz (chamada de "window". Tudo dentro do JS está em um objeto chamado window. Window é um objeto DOM. Que é a janela do navegador)
	
	Dentro do Window existem outros objetos, sendo exemplos:
		Location: Diz a localização do site (URL)
		Document: Documento atual
		History: Guarda de onde você veio, para onde você vai
	Dentro do Document existe outro objeto, chamado html (parte html do site)
	Dentro do html temos 2 objetos (child): head e body / nessa relação, html é um parent (pai) de body e head
	Seguindo no exemplo do arquivo Aula 9.html, dentro de head temos meta e title.
	Já dentro do body, temos h1, 2 parágrafos e uma div.
	Dentro de um dos parágrafos, temos um strong

Navegando pela árvore DOM:

	5 exemplos de método de seleção de elementos:

	Por Marca: Em window: Em document: getElementsByTagName()[]
	Por ID: Em window: Em document: getElementById()
	Por Nome: Em window:  Em document: getElementsByName()[]
	Por Classe: Em window: Em document: getElementsByClassName()[]
	Por Seletor: O mais recomendável! (querySelector() ou querySelectorAll())
		Em window:  Em document: 
			querySelector('div#IdDaDiv'), para ID
			querySelector('div.IdDaClasse'), para Classe

	Sabendo como navegar pelos elementos, podemos declarar variáveis de acesso aos elementos e, através de scripts, utilizar ou modificar os elementos.
	Exemplo:    
		1) Atribuir um ID à div com: <div id="IdDoElemento"> <div/>
		2) Declarar variavel para acesso: var divisao = window.document.getElementById('IdDoElemento')
		3) Fazer mudança ou resgate: divisao.style.background = 'black' / window.alert(divisao.innerText) / divisao.innerText = 'Texto para o qual desejo alterar ou atribuir'
	Exemplo 2, utilizando o método de navegação por Seletor:
		1) Atribuir um ID ou classe à div com: <div id="IdDaDiv"> ou <div class="ClasseDaDiv">
		2) Declarar uma variavel para acesso: var abc = window.document.querySelector('div#IdDaDiv'), quando navegando por ID
																					var abc = window.document.querySelector('div.ClasseDaDiv'), quando navegando por classe.
		3) Fazer mudança ou resgate: abc.style.background = 'black' / window.alert(abc.innerText) / abc.innerText = 'Texto para o qual desejo alterar ou atribuir'

----------------------------------------------------------------------------------------------------------------------------------------------------

EVENTOS DOM - Aula 10 

Eventos podem ser configurados no html ou diretamente no js

html: 
	<div id="x" evento1="func1()" evento2="func2()" evento3="func3()"> alguma texto <div/>

js: 
	var a = document.querySelector('div#x')
	a.addEventListener('event1', func1()) // Está adicionando o event1 na div x, o qual disparará a func1
	A.addEventListener('event2', func2()) // Está adicionando o evento2 na div x, o qual disparará a func2

após configurado o evento, configurar a função:
	function func1() {
		var b = querySelector('div#x')
		b.style.background = 'red'     
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------

CONDICIONAIS - Aula 11 e 12:

Condicao simples:

	if () {
		true
	}

Condição comum: 

	if () {
		true
	} else {
		false
	} 

Consição else if:

	if() {
		true
	} else if{ 
		true
	} else {
		false
	}

Switch:

	switch (expressão) {
		case valor1:
		
		break

		case valor2:

		break

		default:

		break
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------

Conectando ao meu HTML arquivos a parte de CSS e JS:

CSS: Dentro da Head, escrever "link:css" e, em "href", adicionar o nome do arquivo de CSS.
JS: Dentro do Body, escrever "script:src" e, em "src", adicionar o nome do arquivo de JS.
Obs.: Os arquivos que serão utilizados deverão estar na mesma pasta que o arquivo HTML.


! Criar objeto de imagem: <img... >; "src" será o nome do arquivo que será exibido

! Novo imput: radio
	Utilizado para criar uma bolinha de seleçã0 (ex. em "Idade e gênero")
	Para criar multipla escolha, nomear os rads com o mesmo nome.
	Posteriormante, no JS, quando for atribuir o objeto a uma variável, utilizar o GetElementsByName('').
	No momento de criar uma condição, caso seja criada, utilizar esta estrutura:
		if (rad[0].checked) {  // "rad" = identificador da variável

		}

! Criação de um Elemento via JS (ao invés de ir no HTML e inserir):
	var algumnome = document.createElement('tipo de obj') // Neste momento, estamos criando um objeto e atribuindo-o à variável "algumnome"

! Inserindo o objeto criado em determinado "local" do HTML:
	outronome.appendChild(algumnome) // "outronome" é onde vamos inserir o objeto criado "algumnome"). normalmente uma div.

--------------------------------------------------------------------------------------------------------------------------------------------------------

Aula 13 e 14:

While

	Estrutura de repetição com teste lógico no início:

		while (condição) {                  primeiro testa a condição, depois executa.
		ação
		}


	Estrutura de repetição com teste lógico no final:

		do {                                primeira executa a ação, depois testa a condição.
		ação
		} while (condição)

For

	for (início; teste; incremento) {       parte da afirmação feita em "início", testando "teste"
		ação                               	  realiza a ação
	}                                       feita a ação, realiza o incremento 

Adicionar Emoji

	site: https://unicode.org/emoji/charts/full-emoji-list.html
	estrutura: \u{código numérico}    obs: vai vir U+código, só adaptar  
--------------------------------------------------------------------------------------------------------------------------------------------------------
Aula 15:

Array
    
	var identificador = [elemento1, elemento2, elemento3...] -> Índice 0 -> 1 -> 2 

Métodos

	identificador.sort(): ordenar elementos por valor
	identificador.push(x): insere o elemento x no array
	identificador[y] = x: insere o elemento x na posição y
	identificador.indexOf(x): retorna a posição em que o elemento x se encontra no vetor
	identificador.push(): remove o elemento do fim do array
	identificador.shift(): remove o elemento do começo do array 
	identificador.splice(início, removecount, novoItem, novoItem...): editar e criar novos arrays:
		primeiro parâmetro/argumento: índice a partir do qual iniciará o fatiamento/remoção de elementos 
		segundo parãmetro/argumento: número de elementos que serão removidos 
			obs: caso não informado o removeCount, serão removidos todos os elementos a partir do índice indicado.
		terceiro parâmetro/argumento em diante: novos itens que serão adicionados
		ex: 
			let meses = ["Janeiro", "Fevereiro", "Segunda", "Terça"];
			meses.splice(2, 0, "Março");
			console.log(meses); 
			// ["Janeiro", "Fevereiro", "Março", "Segunda", "Terça"]
        
        



For simplificado:
    
	for (var pos in identificador) {               // "Para cada posição no array, imprima": Imprime de um em um
		console.log(identificador[pos])
	}

	Equivalente a: for (pos = 0; pos < identificador.length; pos++) {
		console.log(identificador[pos])
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------
Gerenciamento de memória

	1.Tipos primitivos sempre são passados como um valor (cópia)
		string, number, boolean, null, undefined, symbol
		variáveis declaradas armazenam o VALOR informado.
	2.Tipos não-primitivos são passados como uma referência 
		array, object... etc
		variáveis declaradas armazenam o ENDEREÇO fornecido. 

Assessores SET e GET
	Set: 
		Usando assessores do tipo set podemos alterar a regra de como um atributo pode ou não ser modificado 
		sem precisar alterar isso em diversos pontos do código.
		Usar assessores do tipo set é uma boa prática para garantirmos que a atribuição de propriedades está
		sempre segura.

	Get:
		Utilizado para definir como obter informação do objeto
--------------------------------------------------------------------------------------------------------------------------------------------------------

TIPOS E COERÇÃO:

Tipos Primitivos:

	undefined   
	null
	string
	number
	boolean
	object
	symbol
	
	Em JavaScript variável não possuem tipos, valores sim.
    
NaN:

	Quando temos um retorno NaN, significa que temos uma Operação inválida, e não uma variável que não é um número.
	ex:

	var greeting = "Hello, class!";
	var something = greeting / 2;  
	something;                      // NaN
	Number.isNaN( something );      // true
	Number.isNaN( greeting );       // false

	como podemos, "greeting" não é um número, mas sim uma string. Podem ela não retorna NaN. Pois quem é NaN é 
	a operação something, e não a variável greeting.

New:

	Objetos fundamentais exigem o uso de "new" para instanciamento de novas instancias.

		Use new em:         Não use new em:
		- Objetc()          -  String()
		- Array()           -  Number()
		- Function()        -  Boolean()
		- Date()
		- RegExp()
		- Error()

	ex: 

	var yesterday = new Date("March 6, 2019");
	yesterday.toUTCString();
	// "Wed, 06 Mar 2019 06:00:00 GMT"

	var myGPA = String(transcript.gpa);
	// "3.54"

Coerção:

	O JS possui padrões de coerção que são adotados:
		Number + Number = Number
		String + String = String
		Number + String = String
		String + Number = String

Booleans: 

		Falsy:			Truthy:
		- ""				- todo o resto
		- null			
		- NaN
		- false
		- undefined

Igualdades:

	== permite coerção (aceita diferentes tipos de valor)
		é seguro utilizar quando os tipos das variáveis com as quais se está trabalhando estão claros.
		não é necessariamente ruim. 

	=== não permite coerção (não aceita diferentes tipos de valor)

--------------------------------------------------------------------------------------------------------------------------------------------------------
ESCOPO:

Escopo é onde a informação está (qual camada de informação)

	ex:
		var teacher = "Kyle";
		function otherClass() {
			teacher = "Suzy";					 // Está alterando o valor de uma variável no escopo global, ou seja, de fora do seu escopo.
			topic = "React";           // Cria uma variável no escopo global   
			console.log("Welcome!");
		}
		otherClass(); // Welcome!
		teacher; // ?
		topic;	// ?


Expressões de funções:

	uma expressão de função por si só é vista como um valor, podendo ser atribuídas a variáveis, 
	passadas como argumentos para outras funções, ser retornadas por outras funções, etc.
	Isso faz delas "Valores de primeira classe".

	sobre arrow functions: como são funções anônimas (não possuem nome), é necessário que
	o leitor do código se dedique a compreender o que a função faz. quando temos uma função
	nomeada torna-se óbvio o que ela fa. Desta forma, muitas vezes é melhor darmos um passo
	para trás e usar uma função nomeada

	ex: 

	getPerson()
	.then(person => getData(person.id))		// Leitor precisa se dedicar em entender o que acontece
	.then(renderData);

	getPerson()
	.then(function getDataFrom(person){
		return getData(person.id);					// Fica fácil entender o que está acontecendo.
	})
	.then(renderData);

IFFE (immediately Invoked Function Expression):

	( função(/* ... */) )() 

	A função é imediatamente executada assim que finalizada sua escrita. Além disso, temos 
	um escopo encapsulado dentro da mesma. então se eu atribuir valor a uma variável do meu
	escopo global dentro da função, quando sair para fora da função essa minha variável ainda 
	possuirá seu valor original

Closure (fecho/encerramento):

	"Closure é quando uma função "lembra" de uma variável que está fora de deu escopo, mesmo
	que essa função seja passada para outro lugar, como um parâmetro por ex (isso resgata a 
	ideia de Variável de Primeira Classe)." 

	ex: 

			function makeSizer(size) {
			return function() {
				var resultado = size + 'px';
				return resultado;
			};
		};

		var size6 = makeSizer(6);
		var size12 = makeSizer(12)
		var size15 = makeSizer(15)
		console.log(size12); 			   // '12px'

	Observações importantes:

		Na linha 448, size12 não guarda o return de resultado.
		Ela guarda a função anônima criada dentro de makeSizer "function()", com o parâmetro passado (6).
		Na linha 451, é chamada a função recém criada size12. Esse chamado retorna o retorno de function(6).

		Pensando num caso prático, poderia ter 3 botões de definição de tamanho de fonte de texto, para
		6px, 12px e 15px. Este botão teria um evento. Um evento pede uma função.
		A partir dessa ideia, poderia fazer 3 funções a partir da nossa makeSizer, como se ela fosse uma
		"fábrica de funções", tendo então:

			var size12 = makeSizer(12);
			var size14 = makeSizer(14);
			var size16 = makeSizer(16);

		Agora temos 3 diferentes funções, que podemos retornar para 3 diferentes eventos, tendo 3 diferentes
		botões:

			document.getElementById('size-12').onclick = size12;
			document.getElementById('size-14').onclick = size14;
			document.getElementById('size-16').onclick = size16;
	
--------------------------------------------------------------------------------------------------------------------------------------------------------	
THIS & PROTOTYPES:

	This:

		A palavra-chave "this" faz com que o contexto de uma função seja dinâmico, determinado 
		pela forma como é feita o chamado da função, e não pela forma como foi criada. Diferen-
		temente do visto em Closures, em que o escopo é estático. 
		This = escopo dinâmico.

		IMPORTANTE: a palavra-chave "this." NÃO SIGNIFICA NADA até que seja feito o chamado. 
		É no chamado que ficará definido!!!

		Existem 4 regras que ditam como funciona (aqui são abordadas apenas 2).

		1. Implicit binding rule. ex:

			var workshop = {
				teacher: Henrique,
				ask(question) {
					console.log(this.teacher, question)
				}
			}
			workshop.ask("Hello!")
			
			Não importa que "ask" esteja dentro do objeto "workshop". "this" tem seu significado
			apenas quando o método é chamado. Nesse caso, na linha 492, ao realizar workshop.ask 
			o que acontece é que, implicitamente, "workshop" é atribuído à palavra-chave "this".
			Somente a partir desse momento o "this" que está dentro do console.log passa a apontar 
			para workshop na linha 486 e sabe onde buscar "teacher".

		2. Explicit binding rule. ex:

			function ask(question) {
				console.log(this.teacer, question);
			}
			function otherClass() {
				var myContext = {
					teacher: "Henrique"
				}; 
				ask.call(myContext, "hello!") // Henrique hello! 
			}
			otherClass();

	Prototype:

	Prototype é um objeto a qual instâncias estarão ligadas/delegadas.

	ex:

		function Workshop(teacher) {
			this.teacher = teacher;
		}
		Workshop.prototype.ask = function(question) {
			console.log(this.teacher, question);
		};

		var deepJS = new Workshop("Kyle");
		var reactJS = new Workshop("Suzy");

		deepJS.ask("Is 'prototype' a class?");
		//  Kyle Is 'prototype' a class?

		reactJS.ask("Isn't 'prototype' ugly?");
		// Suzy Isn't 'prototype' ugly?

		Analisando:
			532: O objeto criado é ligado a workshop.prototype (528). 
			528: Workshop.prototype possui um método ask(), e é por isso que:
			535: Mesmo o objeto deepJS não possuindo um método ask(), é possível chamá-lo com deepJS.ask(),
				pois deepJS está ligado, como um protótipo, à workshop.prototype. Com isso, quando chamamos o 
				método, na verdade, estamos delegando esse chamado um level acima da prototype chain, de deepJS 
				para workshop.prototype.

		Observações:
			- deepJS é um objeto
			- deepJS é uma instância de Workshop
			- deepJS é um objeto que contém o parâmetro "teacher"

--------------------------------------------------------------------------------------------------------------------------------------------------------	
ARROW FUNCTIONS 

	Sintaxe:	

		const funcSoma = (a, b) => {  
			return a + b;
		}

	Sendo: 

		funcSoma: nome da função
		(a, b): parâmetros que a funçãoi recebe
		{ ... }: operação que será executada

	ex:

		let roupas = [
			{ produto: 'camisa', preço: 25. cor: 'amarela'},
			{ produto: 'calça', preço: 80, cor: 'azul'},
			{ produto: 'jaqueta', preço: 100, cor: 'preto'},
			{ produto: 'camiseta', preço: 15, cor: 'rosa' },
			{ produto: 'calção', preço: 20, cor: 'azul' },
		];

		let precoMaiorQue50 = roupas.filter(roupa => roupa.preço > 50)
		console.log(precoMaiorQue50)

 --------------------------------------------------------------------------------------------------------------------------------------------------------	

PROMISES

	Como o nome diz, aguarda um retorno. ex: aguarda uma resposta do servidor e, dependendo da resposta, 
	vai retornar uma mensagem de erro ou sucesso.

	Para criar uma Promise, devemos: 
		- Instanciar a classe Promise ( const exp = new Promise(resolve, reject) )
		- Atribuir 2 argumentos à Promise: resolve e reject
		- Caso queira desencadear outros processos utilizamos .then ''

		